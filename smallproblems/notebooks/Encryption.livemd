<!-- livebook:{"autosave_interval_s":60} -->

# Simple Encryption

```elixir
Mix.install(
  [
    {:smallproblems, path: Path.join(__DIR__, ".."), env: :dev}
  ]
)
```

## Caesar's Cipher

[Caesar's cipher](https://en.wikipedia.org/wiki/Caesar_cipher) is one of the simplest and most widely known encryption techniques. It is a type of substitution cipher in which each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet.

The code for this notebook is implemented in the module `Caesar` of the accompanying Elixir project *smallproblems*.

Let's see the code in action by encoding / decoding a simple phrase:

```elixir
pangram = "The\tquick brown fox,\n'jumps' __123__\tover the **lazy** dog!!"
IO.puts(pangram)
cipher = Caesar.encode(pangram, 3)
```

Observe that only ascii letters are encoded; all other characters, including digits, whitespace and punctuation, are removed during encoding.
The main reason for doing so is to blur the lexical structure of the message, making it harder to break the cipher.
This is also reflected in the decoded message:

```elixir
Caesar.decode(cipher, 3)
```

Encoding text messages with *Caesar's cipher* is an example of how to work with [strings](https://hexdocs.pm/elixir/String.html) in Elixir.
Let's go through the code step by step:

```{elixir}
def encode(plaintext, key) when is_binary(plaintext) do
  charlist = plaintext
    |> String.trim
    |> String.upcase
    |> String.to_charlist
  if List.ascii_printable?(charlist) do
    charlist
    |> Enum.map(fn char -> _shift(char, key) end)
    |> List.to_string
    |> String.replace("/", "")
  else
    IO.puts("Cannot encode #{charlist}.")
  end
end
```

The function `encode` is defined with a [guard](https://hexdocs.pm/elixir/patterns-and-guards.html), introduced with the keyword `when`: this function clause matches only if the first argument `plaintext` is a *binary*, i.e. a string.
Calling `encode` with any other argument will lead to a *FunctionClauseError*;
so we define a second function clause

```{elixir}
def encode(_something, _key) do
  IO.puts("Cannot encode something else than strings.")
end
```

just to inform the user that `encode` only works with strings.
This clause will always match if the first argument is not a string.

```elixir
Caesar.encode([1,2,3], 3)
```

There's more than one way to work with strings: in an imperative setting we would iterate over the characters of the string (probably with a for-loop) and apply the desired transformations step by step.\
But with functional programming we have another choice: first, we transform the string into a list of characters, and then use the *higher-order* function `Enum.map` to apply the transformations at once.
Here's the first step:

<!-- livebook:{"force_markdown":true} -->

```elixir
charlist = plaintext
  |> String.trim
  |> String.upcase
  |> String.to_charlist
```

<!-- livebook:{"break_markdown":true} -->

The result of the expression to the right of `=` is bound to the value `charlist`.
The expression consists of three function calls, joined with the pipe-operator `|>`: clean up the string, convert it to upper-case characters, and transform it into a list of integer codepoints.

Observe that the resulting `charlist` is in fact a list of integers, i.e. the decimal representation of the respective character codepoints.
This fact will prove useful when shifting the characters later.
If the list consists only of printable ascii characters, we apply the second step (the actual transformation):

<!-- livebook:{"force_markdown":true} -->

```elixir
if List.ascii_printable?(charlist) do
  charlist
    |> Enum.map(fn char -> _shift(char, key) end)
    |> List.to_string
    |> String.replace("/", "")
```

Here, the call to `Enum.map` is the important part, where the characters are shifted to their new position.
Afterwards, the `charlist` is converted back to a string, and finally some not convertible characters `/` are removed.

If the `charlist` contains non-ascii characters, we inform the user that the message cannot be encoded:

<!-- livebook:{"force_markdown":true} -->

```elixir
if List.ascii_printable?(charlist) do
  ...
else
  IO.puts("Cannot encode #{charlist}.")
end
```

```elixir
Caesar.encode("héllò", 3)
```

But now to the main part of our program's logic: shifting each character by a number of `key` positions. 
The function `_shift` is marked as *hidden* with a leading underscore `_`, giving users a hint that it is not part of the module's public API.
I could have made the function entirely *private* by using `defp` instead, but then we wouldn't be able to call it in this notebook.

`_shift` is called by `Emum.map` for every codepoint of the `charlist`; it is implemented like so:

<!-- livebook:{"force_markdown":true} -->

```elixir
def _shift(char, key) do
  if char >= ?A and char <= ?Z do
    norm = char - ?A
    Integer.mod(norm + key, 26) + ?A
  else
    ?/
  end
end
```

<!-- livebook:{"break_markdown":true} -->

If the current character is an upper-case letter (A, B, C, ..., Z), we normalize it by subtracting `?A`, which is the ascii integer code for the character `A`, i.e. 65.
With that, the letter is reperesented by a number between `A=0` and `Z=25`.\
Now we compute $norm + key \mod 26$, to make sure that the shifted value stays in in the range `0..25`.
The `Integer.mod` function implements the [modulo operation](https://en.wikipedia.org/wiki/Modulo), which calculates the remainder of an euclidian division with the given arguments.
Finally, we add `?A` to get the actual (denormalized) letter.

Let's give an example for `Y=89` and `key=3`:
$$
\begin{align*}
norm = 89-65 &= 24 \\
(24+3) \mod 26 &= 1 \\
1 + 65 = 66 &= \textrm{B}
\end{align*}
$$
So, we have shifted `Y` 3 places down the aplphabet to `B` (Z->A->B), respecting the turn-over at the beginning/end of the alphabet.

```elixir
Caesar._shift(?Y, 3)
```

If the current character is not an upper-case letter, we return an arbitrary `/` character, since we don't know how to convert it.
We could also return the character unchanged (maintaining digits, whitespace and punctuation), but this would make the cipher easy to break.

## Breaking Caesar's Cipher

As with all single-alphabet substitution ciphers, the Caesar cipher is easily broken and in modern practice offers essentially no communications security.

We want to break the cipher with a technique called [frequency analysis](https://en.wikipedia.org/wiki/Frequency_analysis).

To that end, the module `Caesar` defines a [module attribute](https://hexdocs.pm/elixir/module-attributes.html) `@expected`, which represents a *frequency table* for the distribution of the 26 letters from the English alphabet.
In the English language, the letters E, T, A and O are the most common, while Z, Q, X and J are rare.

<!-- livebook:{"force_markdown":true} -->

```elixir
@expected [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0,
           0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0,
           6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1]
```

Our plan is to compute the frequency distribution for the letters of the cipher and compare it with the expected distrubution of letters, using a statistical method called [chi-square test](https://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test).

The `break` function of our module `Caesar` implements this plan:

<!-- livebook:{"force_markdown":true} -->

```elixir
def break(cipher) when is_binary(cipher) do
  observed = _frequencies(cipher)
  chi_stats = for n <- 0..25 do
    _chi_square(_rotate(observed, n), @expected)
  end
  key = Enum.find_index(chi_stats, &(&1 == Enum.min(chi_stats)))
  decode(cipher, key)
end
```

<!-- livebook:{"break_markdown":true} -->

First, we compute the frequency distribution of the cipher by calling the function `_frequencies` and bind the result to a value `observed`.

Here's how the function `_frequencies` works:

<!-- livebook:{"force_markdown":true} -->

```elixir
def _frequencies(text) do
  charlist = String.to_charlist(text)
  m = length(charlist)
  for c <- ?A..?Z do
    n = Enum.count(charlist, &(&1 == c))
    (n / m) * 100
  end
end
```

<!-- livebook:{"break_markdown":true} -->

The expression `for c <- ?A..?Z do` generates a [comprehension](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#for/1), where the letters A to Z are mapped to their number of occurences in the `charlist`.
After that, the frequency of every letter is computed as a percentage with respect to the total number of letters.

For example:

```elixir
Caesar._frequencies("ABBCCCDDDDEEEEE")
```

The next expression of the main function `break`

<!-- livebook:{"force_markdown":true} -->

```elixir
chi_stats = for n <- 0..25 do
  _chi_square(_rotate(observed, n), @expected)
end
```

is the **heart of our logic**:
we generate a comprehension for every possible shifting key (0-25), and compute the *chi-square statistic* for the resulting frequency tables.

For shifting the frequencies, we use the function `_rotate`

<!-- livebook:{"force_markdown":true} -->

```elixir
def _rotate(collection, n) do
  Enum.drop(collection, n) ++ Enum.take(collection, n)
end
```

which just shifts the elements of a given collection by `n` positions, wrapping around at the start of the collection like so:

```elixir
Caesar._rotate([1, 2, 3, 4, 5], 1)
```

The *chi-square test* determines whether an observed frequency distribution matches a theoretical distribution (in our case the `@expected` distribution of letters).\
The *chi-square statistic* can be computed with the formula
$$
\chi^2 = \sum{\frac{(O_i - E_i)^2}{E_i}},
$$
where

* $\chi^2$ = the chi-square statistic value
* $O_i$ = the observed frequency for each letter
* $E_i$ = the expected frequency for each letter
* $\sum$ = the summation symbol, meaning the calculation is performed for every letter and the results are summed.

We can translate the above formula into a function definition like so:

<!-- livebook:{"force_markdown":true} -->

```elixir
def _chi_square(observed, expected) do
  data = for {o, e} <- Enum.zip(observed, expected) do
    Float.pow(o-e, 2) / e
  end
  Enum.sum(data)
end
```

<!-- livebook:{"break_markdown":true} -->

This definition again uses a comprehension, where the single values for `o` and `e` are generated by combining their respective frequency tables into a single collection with `Enum.zip`.

The datails of the *chi-square* statistic need not concern us, only the fact that the smaller the value it produces the better the match between the two frequency tables.\
Thus, we just need to find the minumum value of the resulting `chi_stats` collection and its position in this collection, which will correspond to the key used for encyption.

<!-- livebook:{"force_markdown":true} -->

```elixir
key = Enum.find_index(chi_stats, &(&1 == Enum.min(chi_stats)))
```

Finally, we can decode the cipher with that key:

<!-- livebook:{"force_markdown":true} -->

```elixir
decode(cipher, key)
```

Now it's time to test our algorithm:

```elixir
cipher = Caesar.encode("Functional programming is fun!", 7)
IO.puts(cipher)
Caesar.break(cipher)
```

In general, the `break` function can decode most strings produced using Caesar's cipher.
However, it may not be successful if the string is short or has an unusual distribution of letters.
For example:

```elixir
Caesar.break(Caesar.encode("Elixir", 3))
```

```elixir
Caesar.break(Caesar.encode("boxing wizards jump quickly", 3))
```

In contrast, our introductory example can be cracked, even though it is a [pangram](https://en.wikipedia.org/wiki/Pangram) with a quite unusual distribution of letters.

```elixir
cipher = Caesar.encode(pangram, 17)
IO.puts(cipher)
Caesar.break(cipher)
```

## One-time Pad (OTP)

In this section we'll implement another encryption technique, called [One-time pad](https://en.wikipedia.org/wiki/One-time_pad), which cannot be cracked.\
To make things more interesting we'll implement two versions of the algorithm: an ancient version, which was used for centuries and can be applied just using pen and paper; and a more modern variant, for which you might use a computer.

### An ancient version with letters only

Let's see the ancient version in action:

```elixir
message = "Functional programming is fun!"
{cipher, key} = OTP.encrypt(message, :ascii)
```

We get two values: the encoded message and a random secret key; both of them are human readable strings and each could simply be written on a sheet of paper.

```elixir
String.valid?(cipher)
```

But you have to make sure that the key remains secret, so you can't send both parts in a single message.
If you'd do so, everyone could crack the cipher:

```elixir
OTP.decrypt(cipher, key)
```

However, not possessing the secret key makes it impossible to crack the cipher, for sure not with our `break` function from `Caesar`:

```elixir
Caesar.break(cipher)
```

How is this possible, using only ancient techniques?
Let's go through the code step by step to solve this puzzle:

<!-- livebook:{"force_markdown":true} -->

```elixir
def encrypt(plaintext, format \\ :unicode)

def encrypt(plaintext, _format = :ascii) do
  cleaned = plaintext
    |> String.replace(~r/[^[:alpha:]]/, "")
    |> String.upcase
  encrypt_ascii(cleaned)
end
```

The function `encrypt` has a *function head*, i.e. a clause without a body.
This serves for defining a *default* value for the second argument `format`, which is set to `:unicode` if the format is not specified.

If the format is specified with `:ascii` the second clause will match.\
In this case, the provided `plaintext` will be cleaned by removing all characters, which are *not* a letter.
For this task we use a [regular expression](https://hexdocs.pm/elixir/Regex.html) `~r/[^[:alpha:]]/`, and therein a *character class* `[:alpha]` which matches only letters.
The caret character `^` inside a regular expression normally denotes the beginning of the string to be matched.
But inside a character class, it just negates the given class.

The string is then converted to upper-case, and finally `encrypt_ascii` is called with the cleaned string:

<!-- livebook:{"break_markdown":true} -->

<!-- livebook:{"force_markdown":true} -->

```elixir
defp encrypt_ascii(message) do
  msg = String.to_charlist(message)
  key = random_letters(length(msg))
  cipher = for {m, k} <- Enum.zip(msg, key) do
    Integer.mod((m-?A) + (k-?A), 26) + ?A
  end
  {List.to_string(cipher), List.to_string(key)}
end
```

Here, the `message` is converted to a charlist, and a random `key` of the same length is generated by calling `random_letters`, which produces another charlist.\
Having both charlists in place, we generate the `cipher` with help of a list comprehension and a *modulo* operation, analogous to what we did for Caesar's cipher.\
But, in contrast to our `Caesar._shift` function (where every letter was encoded with the same key), every letter is now encoded with a different, random key.\
And that makes the cipher so hard to break: even if one ore more letters have been revealed, one still has no clue how the remaining letters were encoded.
Even worse: we cannot decide whether a letter was correctly decoded until the whole message is decoded.

<!-- livebook:{"break_markdown":true} -->

Let's take a look at the helper function `random_letters`, which generates the random key:

<!-- livebook:{"force_markdown":true} -->

```elixir
defp random_letters(0), do: []
defp random_letters(n) do
  letter = :rand.uniform(25) + ?A
  [letter | random_letters(n-1)]
end
```

This is a recursive function, where the *base case* for `n=0` returns an empty list.
The *recursive clause* computes a random letter in the range A..Z.
The letter is then added to the resulting list by concatenating it with the recursive function call, which will eventually lead to the base case (the empty list).

<!-- livebook:{"break_markdown":true} -->

With that knowledge decrypting is easy: we just reverse the encryption process.
Instead of adding the key to the massage, we subtract the key from the cipher for every letter:

<!-- livebook:{"force_markdown":true} -->

```elixir
defp decrypt_ascii(cipher, key) do
  cip = String.to_charlist(cipher)
  key = String.to_charlist(key)
  cleartext = for {c, k} <- Enum.zip(cip, key) do
    Integer.mod((c-?A) - (k-?A), 26) + ?A
  end
  cleartext |> List.to_string() |> String.downcase
end
```

<!-- livebook:{"break_markdown":true} -->

### A modern approach

If we don't specify a format for the encryption then the default option will take effect:

<!-- livebook:{"force_markdown":true} -->

```elixir
def encrypt(plaintext, _format) do
  encrypt_unicode(plaintext, <<>>, <<>>)
end
```

In this case we just call `encrypt_unicode`, providing the `plaintext` and two additional parameters, each representing an empty binary.

So far, we have worked with strings using functions from the `String` module, or we have converted them to charlists, and then used functions from the `List` and `Enum` modules.

But now we'll work directly with [binaries](https://hexdocs.pm/elixir/binaries-strings-and-charlists.html), which are *binary* data structures, holding the string data.
A `binary` in Elixir is a just a `bitstring` where the number of bits is divisible by 8.
That is, a `binary` stores consecutive bytes, each consisting of 8 bits.

We can destructure a binary using pattern matching like so:

```elixir
<<char, rest::binary>> = "hello"
char == ?h
```

Here, `char` matches the first byte of the string "hello".
We can view the whole string as a collection of single bytes by appending a zero byte with the concatenation operator `<>`:

```elixir
"hello" <> <<0>>
```

With that, we can define the function `encrypt_unicode` as:

<!-- livebook:{"force_markdown":true} -->

```elixir
defp encrypt_unicode(<<>>, cipher, key), do: {cipher, key}
defp encrypt_unicode(<<m, rest::binary>>, cipher, key) do
  k = :rand.uniform(255)
  c = bxor(m, k)
  encrypt_unicode(rest, <<c>> <> cipher, <<k>> <> key)
end
```

This is again a recursive function with a *base case* for an empty binary as its first parameter (the original `message`):
when the text is completely consumed, return the tuple `{cipher, key}`.\
Observe that `cipher` and `key` are parameters of the function: we use them as *accumulators*, storing the intermediate results of the recursive steps; both accumulators are initially empty.

The *recursive clause* pattern-matches on the `message`, extracting its first byte `m`.\
`k` is a single random key in the range 0..255, i.e. a single byte.\
The next byte of the cipher `c` is computed with `bxor(m, k)`, where `bxor` implements the [exclusive or](https://en.wikipedia.org/wiki/Exclusive_or) operation(defined in the standard library's module [Bitwise](https://hexdocs.pm/elixir/Bitwise.html)).\
Finally, the function calls itself, providing the remaining bytes of the message (`rest`) as its first parameter.
The accumulators are updated by concatenating the respective bytes: `<<c>> <> cipher` and `<<k>> <> key`.

Let's test our encryption with a simple message:

```elixir
message = "This is a *test*\nwith `digits` 123,\tand _punctuation_!"
IO.puts(message)
{cipher, key} = OTP.encrypt(message)
```

`cipher` and `key` are now just binaries.
Since they contain non-printable characters, they don't represent valid strings.
Hence, Elixir displays them as bitstrings.

```elixir
String.valid?(cipher)
```

We use this fact to decide which algorithm we're going to use for decrypting:

<!-- livebook:{"force_markdown":true} -->

```elixir
def decrypt(cipher, key) do
  if String.valid?(cipher) do
    decrypt_ascii(cipher, key)
  else
    decrypt_unicode(cipher, <<>>, key)
  end
end
```

The only thing remaining is to define `decrypt_unicode`:

<!-- livebook:{"force_markdown":true} -->

```elixir
defp decrypt_unicode(<<>>, message, _key), do: message
defp decrypt_unicode(<<c, cipher::binary>>, message, <<k, key::binary>>) do
  m = bxor(c, k)
  decrypt_unicode(cipher, <<m>> <> message, key)
end
```

The *base case* for an empty `cipher` just returns the decrypted `message`.\
The *recursive clause* pattern-matches on `cipher` and `key`, both representing binaries.
The *decryption* just reverses the *encryption* to reproduce the original byte:
$$
\begin{align*}
c = m &\oplus k \\
m = c &\oplus k,
\end{align*}
$$
where $\oplus$ denotes the *bitwise xor* operator (implemented by the `Bitwise.bxor` function).\
$\oplus$ compares two integer numbers in their respective bit-representation and returns a `1` bit for each position if the numbers differ at this position.

<!-- livebook:{"break_markdown":true} -->

Let's illustrate how this works with a simple example:
$$
\begin{align*}
m = A = 65 &= 1000001 \\
k = Z = 90 &= 1011010 \\
c = m \oplus k &= 0011011 \\
m = c \oplus k &= 1000001 = 65 = A \\
\end{align*}
$$

With that, we can decrypt our test message like so:

```elixir
cleartext = OTP.decrypt(cipher, key)
IO.puts(cleartext)
cleartext == message
```

Given that Elixir uses UTF-8 to encode its strings (which means that code points are encoded as a series of 8-bit bytes), we can even encrypt text containing [unicode](https://en.wikipedia.org/wiki/Unicode) codepoints without loss:

```elixir
message = "¿Hola, cómo estás?"
IO.puts(message)
{cipher, key} = OTP.encrypt(message)
cleartext = OTP.decrypt(cipher, key)
IO.puts(cleartext)
cleartext == message
```
