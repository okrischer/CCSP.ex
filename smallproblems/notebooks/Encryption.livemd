<!-- livebook:{"autosave_interval_s":60} -->

# Caesar's Cipher

```elixir
Mix.install(
  [
    {:smallproblems, path: Path.join(__DIR__, ".."), env: :dev}
  ]
)
```

## Encoding / Decoding

[Caesar's cipher](https://en.wikipedia.org/wiki/Caesar_cipher) is one of the simplest and most widely known encryption techniques. It is a type of substitution cipher in which each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet.

The code for this notebook is implemented in the module `Caesar` of the accompanying Elixir project *smallproblems*.

Let's see the code in action by encoding / decoding a simple phrase:

```elixir
pangram = "The\tquick brown fox,\n'jumps' __123__\tover the **lazy** dog!!"
IO.puts(pangram)
cipher = Caesar.encode(pangram, 3)
```

Observe that only ascii letters are encoded; all other characters, including digits, whitespace and punctuation, are removed during encoding.
The main reason for doing so is to blur the lexical structure of the message, making it harder to break the cipher.
This is also reflected in the decoded message:

```elixir
Caesar.decode(cipher, 3)
```

### Working with Strings

Encoding a message with *Caesar's cipher* is an example of how to work with [strings](https://hexdocs.pm/elixir/String.html) in Elixir.
Let's go through the code step by step:

```{elixir}
def encode(plaintext, key) when is_binary(plaintext) do
  charlist = plaintext
    |> String.trim
    |> String.upcase
    |> String.to_charlist
  if List.ascii_printable?(charlist) do
    charlist
    |> Enum.map(fn char -> _shift(char, key) end)
    |> List.to_string
    |> String.replace("/", "")
  else
    IO.puts("Cannot encode #{charlist}.")
  end
end
```

The function `encode` is defined with a [guard](https://hexdocs.pm/elixir/patterns-and-guards.html), introduced with the keyword `when`: this function clause matches only if the first argument `plaintext` is a *binary*, i.e. a string.
Calling `encode` with any other argument will lead to a *FunctionClauseError*;
so we define a second function clause

```{elixir}
def encode(_something, _key) do
  IO.puts("Cannot encode something else than strings.")
end
```

just to inform the user that `encode` only works with strings.
This clause will always match if the first argument is not a string.

```elixir
Caesar.encode([1,2,3], 3)
```

There's more than one way to work with strings: in an imperative setting we would iterate over the characters of the string (probably with a for-loop) and apply the desired transformations step by step.\
But with functional programming we have another choice: first, we transform the string into a list of characters, and then use the *higher-order* function `Enum.map` to apply the transformations at once.
Here's the first step:

<!-- livebook:{"force_markdown":true} -->

```elixir
charlist = plaintext
  |> String.trim
  |> String.upcase
  |> String.to_charlist
```

<!-- livebook:{"break_markdown":true} -->

The result of the expression to the right of `=` is bound to the value `charlist`.
The expression consists of three function calls, joined with the pipe-operator `|>`: clean up the string, convert it to upper-case characters, and transform it into a list of integer codepoints.

Observe that the resulting `charlist` is in fact a list of integers, i.e. the decimal representation of the respective character codepoints.
This fact will prove useful when shifting the characters later.
If the list consists only of printable ascii characters, we apply the second step (the actual transformation):

<!-- livebook:{"force_markdown":true} -->

```elixir
if List.ascii_printable?(charlist) do
  charlist
    |> Enum.map(fn char -> _shift(char, key) end)
    |> List.to_string
    |> String.replace("/", "")
```

Here, the call to `Enum.map` is the important part, where the characters are shifted to their new position.
Afterwards, the `charlist` is converted back to a string, and finally some not convertible characters `/` are removed.

If the `charlist` contains non-ascii characters, we inform the user that the message cannot be encoded:

<!-- livebook:{"force_markdown":true} -->

```elixir
if List.ascii_printable?(charlist) do
  ...
else
  IO.puts("Cannot encode #{charlist}.")
end
```

```elixir
Caesar.encode("héllò", 3)
```

But now to the main part of our program's logic: shifting each character by a number of `key` positions. 
The function `_shift` is marked as *hidden* with a leading underscore `_`, giving users a hint that it is not part of the module's public API.
I could have made the function entirely *private* by using `defp` instead, but then we wouldn't be able to call it in this notebook.

`_shift` is called by `Emum.map` for every codepoint of the `charlist`; it is implemented like so:

<!-- livebook:{"force_markdown":true} -->

```elixir
def _shift(char, key) do
  if char >= ?A and char <= ?Z do
    norm = char - ?A
    Integer.mod(norm + key, 26) + ?A
  else
    ?/
  end
end
```

<!-- livebook:{"break_markdown":true} -->

If the current character is an upper-case letter (A, B, C, ..., Z), we normalize it by subtracting `?A`, which is the ascii integer code for the character `A`, i.e. 65.
With that, the letter is reperesented by a number between `A=0` and `Z=25`.\
Now we compute $norm + key \mod 26$, to make sure that the shifted value stays in in the range `0..25`.
The `Integer.mod` function implements the [modulo operation](https://en.wikipedia.org/wiki/Modulo), which calculates the remainder of an euclidian division with the given arguments.
Finally, we add `?A` to get the actual (denormalized) letter.

Let's give an example for `Y=89` and `key=3`:
$$
\begin{align*}
norm = 89-65 &= 24 \\
(24+3) \mod 26 &= 1 \\
1 + 65 = 66 &= \textrm{B}
\end{align*}
$$
So, we have shifted `Y` 3 places down the aplphabet to `B` (Z->A->B), respecting the turn-over at the beginning/end of the alphabet.

```elixir
Caesar._shift(?Y, 3)
```

If the current character is not an upper-case letter, we return an arbitrary `/` character, since we don't know how to convert it.
We could also return the character unchanged (maintaining digits, whitespace and punctuation), but this would make the cipher easy to break.

## Breaking Caesar's Cipher

As with all single-alphabet substitution ciphers, the Caesar cipher is easily broken and in modern practice offers essentially no communications security.

We want to break the cipher with a technique called [frequency analysis](https://en.wikipedia.org/wiki/Frequency_analysis).

To that end, the module `Caesar` defines a [module attribute](https://hexdocs.pm/elixir/module-attributes.html) `@expected`, which represents a *frequency table* for the distribution of the 26 letters from the English alphabet.
In the English language, the letters E, T, A and O are the most common, while Z, Q, X and J are rare.

<!-- livebook:{"force_markdown":true} -->

```elixir
@expected [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0,
           0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0,
           6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1]
```

Our plan is to compute the frequency distribution for the letters of the cipher and compare it with the expected distrubution of letters, using a statistical method called [chi-square test](https://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test).

The `break` function of our module `Caesar` implements this plan:

<!-- livebook:{"force_markdown":true} -->

```elixir
def break(cipher) when is_binary(cipher) do
  observed = _frequencies(cipher)
  chi_stats = for n <- 0..25 do
    _chi_square(_rotate(observed, n), @expected)
  end
  key = Enum.find_index(chi_stats, &(&1 == Enum.min(chi_stats)))
  decode(cipher, key)
end
```

<!-- livebook:{"break_markdown":true} -->

First, we compute the frequency distribution of the cipher by calling the function `_frequencies` and bind the result to a value `observed`.

Here's how the function `_frequencies` works:

<!-- livebook:{"force_markdown":true} -->

```elixir
def _frequencies(text) do
  charlist = String.to_charlist(text)
  m = length(charlist)
  for c <- ?A..?Z do
    n = Enum.count(charlist, &(&1 == c))
    (n / m) * 100
  end
end
```

<!-- livebook:{"break_markdown":true} -->

The expression `for c <- ?A..?Z do` generates a [comprehension](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#for/1), where the letters A to Z are mapped to their number of occurences in the `charlist`.
After that, the frequency of every letter is computed as a percentage with respect to the total number of letters.

For example:

```elixir
Caesar._frequencies("ABBCCCDDDDEEEEE")
```

The next expression of the main function `break`

<!-- livebook:{"force_markdown":true} -->

```elixir
chi_stats = for n <- 0..25 do
  _chi_square(_rotate(observed, n), @expected)
end
```

is the **heart of our logic**:
we generate a comprehension for every possible shifting key (0-25), and compute the *chi-square statistic* for the resulting frequency tables.

For shifting the frequencies, we use the function `_rotate`

<!-- livebook:{"force_markdown":true} -->

```elixir
def _rotate(collection, n) do
  Enum.drop(collection, n) ++ Enum.take(collection, n)
end
```

which just shifts the elements of a given collection by `n` positions, wrapping around at the start of the collection like so:

```elixir
Caesar._rotate([1, 2, 3, 4, 5], 1)
```

The *chi-square test* determines whether an observed frequency distribution matches a theoretical distribution (in our case the `@expected` distribution of letters).\
The *chi-square statistic* can be computed with the formula
$$
\chi^2 = \sum{\frac{(O_i - E_i)^2}{E_i}},
$$
where

* $\chi^2$ = the chi-square statistic value
* $O_i$ = the observed frequency for each letter
* $E_i$ = the expected frequency for each letter
* $\sum$ = the summation symbol, meaning the calculation is performed for every letter and the results are summed.

We can translate the above formula into a function definition like so:

<!-- livebook:{"force_markdown":true} -->

```elixir
def _chi_square(observed, expected) do
  data = for {o, e} <- Enum.zip(observed, expected) do
    Float.pow(o-e, 2) / e
  end
  Enum.sum(data)
end
```

<!-- livebook:{"break_markdown":true} -->

This definition again uses a comprehension, where the single values for `o` and `e` are generated by combining their respective frequency tables into a single collection with `Enum.zip`.

The datails of the *chi-square* statistic need not concern us, only the fact that the smaller the value it produces the better the match between the two frequency tables.\
Thus, we just need to find the minumum value of the resulting `chi_stats` collection and its position in this collection, which will correspond to the key used for encyption.

<!-- livebook:{"force_markdown":true} -->

```elixir
key = Enum.find_index(chi_stats, &(&1 == Enum.min(chi_stats)))
```

Finally, we can decode the cipher with that key:

<!-- livebook:{"force_markdown":true} -->

```elixir
decode(cipher, key)
```

Now it's time to test our algorithm:

```elixir
cipher = Caesar.encode("Functional programming is fun!", 7)
IO.puts(cipher)
Caesar.break(cipher)
```

In general, the `break` function can decode most strings produced using Caesar's cipher.
However, it may not be successful if the string is short or has an unusual distribution of letters.
For example:

```elixir
Caesar.break(Caesar.encode("Elixir", 3))
```

```elixir
Caesar.break(Caesar.encode("boxing wizards jump quickly", 3))
```

In contrast, our introductory example can be cracked, even though it is a [pangram](https://en.wikipedia.org/wiki/Pangram) with an unusual distribution of letters.

```elixir
cipher = Caesar.encode(pangram, 17)
IO.puts(cipher)
Caesar.break(cipher)
```

Our algorithm is able to crack *Caesar's cipher* in virtually no time.
